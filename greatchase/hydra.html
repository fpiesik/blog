<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Hydra + OBS + MIDI – Chase Playground</title>
  <style>
    html,body{margin:0;background:#000}
    canvas{width:100vw;height:100vh;display:block}
    #obsCam{position:fixed;left:-10000px;top:-10000px;width:1px;height:1px}
  </style>
  <!-- lokal eingebunden -->
  <script src="./hydra-synth.js"></script>
</head>
<body>

  <!-- persistentes, verstecktes Videoelement -->
  <video id="obsCam" muted playsinline></video>

<script type="module">
  // -------- Hydra init --------
  const hydra = new Hydra({ detectAudio:true, makeGlobal:true, pixelRatio: 1 });
  a.setBins(8);

  // -------- Kamera auswählen (per Label-Substring) --------
  const camLabel = "OBS"; // z.B. "OBS", "Logitech", "USB"
  const vidEl = document.getElementById('obsCam');
  let currentStream = null;

  async function ensureMediaPermission() {
    try { await navigator.mediaDevices.getUserMedia({ video:true }); } catch {}
  }
  async function listCams() {
    await ensureMediaPermission();
    const devs = await navigator.mediaDevices.enumerateDevices();
    return devs.filter(d => d.kind === 'videoinput');
  }
  async function setCamera(labelSubstr) {
    const cams = await listCams();
    const cam = cams.find(c => c.label.includes(labelSubstr)) || cams[0];
    if (!cam) throw new Error("Keine Kamera gefunden!");
    if (currentStream) currentStream.getTracks().forEach(t=>t.stop());
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { deviceId: { exact: cam.deviceId } }, audio:false
    });
    currentStream = stream;
    vidEl.srcObject = stream;
    try { await vidEl.play(); } catch(e){ console.warn("play() warn:", e); }
    if (!setCamera._init) {
      s1.init({ src: vidEl, dynamic:true }); // nur 1× initialisieren
      //s1.initVideo("./greatchasem8.mkv"); // lokal
      setCamera._init = true;
    }
  }
  await setCamera(camLabel);

  // -------- Parameter --------
  const P = {
    // Bildquelle (s0 / Szene)
    img_speed:0.0,
    img_scl:{src:0,fac:0.0,att:0.1,rel:0.25,abs:0},
    img_mov:{src:0,fac:0.0,att:0.1,rel:0.25,dir:[1,0]},
    img_col:{src:6,fac:0.0,att:0.1,rel:0.25,h:0.3,s:0.3,v:0.3,ho:0,so:0,vo:0},
    img_warp:0.0, img_wspd:0.1,

    // Videoquelle (s1 / Tracker)
    vid_speed:0.0,
    vid_scl:{src:0,fac:0.0,att:0.1,rel:0.25,abs:0},
    vid_mov:{src:0,fac:0.0,att:0.1,rel:0.25,dir:[1,0]},
    vid_col:{src:6,fac:0.0,att:0.1,rel:0.25,h:0.3,s:0.3,v:0.3,ho:0,so:1,vo:0},
    vid_warp:0.0, vid_wspd:0.1,

    // Sirene (weicher Gradient)
    siren:0.0, sir_spd:0.20, sir_w:0.35, sir_dir:'x',
    sirA:[1.0,0.05,0.05], sirB:[0.05,0.2,1.0],

    // Mix
    blend:1, trail:0.22
  };

  // -------- Scroll-Startanker (neu) --------
  // Startzeitpunkte, ab denen das "integrierte" Scrollen beginnt
  let imgSpeedStart = 0;
  let prevImgSpeed = P.img_speed;

  // (optional auch für Video, falls du das gleiche Verhalten dort willst)
  let vidSpeedStart = 0;
  let prevVidSpeed = P.vid_speed;

  // liefert den Basis-Scroll aus der statischen Geschwindigkeit,
  // startet bei 0 genau beim Moment des Aktivierens
  const baseImgScroll = () => (P.img_speed !== 0 ? (time - imgSpeedStart) * P.img_speed : 0);
  const baseVidScroll = () => (P.vid_speed !== 0 ? (time - vidSpeedStart) * P.vid_speed : 0);

  // -------- Dynamische Envelopes (lesen P live, kein Rebuild nötig) --------
  function makeDynEnv(getSrc, getAtt, getRel, getFac){
    let y = 0, tPrev = 0;
    return function(){
      const idx = Math.max(0, Math.min(7, getSrc()));
      const x = a.fft[idx] || 0;
      const t = time || 0;
      const dt = Math.max(0.0005, t - tPrev);
      const att = Math.max(0.0005, getAtt());
      const rel = Math.max(0.0005, getRel());
      const aUp = 1 - Math.exp(-dt/att);
      const aDn = 1 - Math.exp(-dt/rel);
      y += (x > y ? aUp : aDn) * (x - y);
      tPrev = t;
      return y * getFac();
    }
  }

  const vS = makeDynEnv(()=>P.vid_scl.src, ()=>P.vid_scl.att, ()=>P.vid_scl.rel, ()=>P.vid_scl.fac);
  const vM = makeDynEnv(()=>P.vid_mov.src, ()=>P.vid_mov.att, ()=>P.vid_mov.rel, ()=>P.vid_mov.fac);
  const vC = makeDynEnv(()=>P.vid_col.src, ()=>P.vid_col.att, ()=>P.vid_col.rel, ()=>P.vid_col.fac);

  const iS = makeDynEnv(()=>P.img_scl.src, ()=>P.img_scl.att, ()=>P.img_scl.rel, ()=>P.img_scl.fac);
  const iM = makeDynEnv(()=>P.img_mov.src, ()=>P.img_mov.att, ()=>P.img_mov.rel, ()=>P.img_mov.fac);
  const iC = makeDynEnv(()=>P.img_col.src, ()=>P.img_col.att, ()=>P.img_col.rel, ()=>P.img_col.fac);

  // -------- Sirene (weicher, zyklischer Gradient) – funktional --------
  const sirMask = () =>
    osc(() => Math.max(0.05, 1/Math.max(0.05, P.sir_w)),
        () => P.sir_spd, 0)
      .saturate(0)
      .rotate(() => P.sir_dir==='y' ? Math.PI/2 : 0);

  const sirOneMinus = () => solid(1,1,1).diff(sirMask());
  const sirAtex = () => solid(() => P.sirA[0], () => P.sirA[1], () => P.sirA[2]).mult(sirOneMinus());
  const sirBtex = () => solid(() => P.sirB[0], () => P.sirB[1], () => P.sirB[2]).mult(sirMask());
  const sirenTex = () => sirAtex().add(sirBtex()).brightness(0.06);

  // -------- Modulatoren (funktional) --------
  const noiseI = () => noise(3, () => P.img_wspd);
  const noiseV = () => noise(3, () => P.vid_wspd);

  // -------- Quellen EINMAL initialisieren --------
  s0.initImage("./chase1920x1080.png"); // lokal

  // -------- Node-Graph EINMAL definieren --------
  const imgNode = () => src(s0).scale(1,1)
    .scrollX(() => baseImgScroll() + time*P.img_mov.dir[0]*iM())  // <— geändert
    .scrollY(() =>              time*P.img_mov.dir[1]*iM())
    .scale(() => P.img_scl.abs + 1 + iS())
    .modulate(noiseI(), () => P.img_warp * 0.05)
    .hue(() => P.img_col.ho + P.img_col.h * iC())
    .saturate(() => P.img_col.so + P.img_col.s * iC())
    .brightness(() => P.img_col.vo + P.img_col.v * iC());

  const camNode = () => src(s1)
    .scrollX(() => baseVidScroll() + time*P.vid_mov.dir[0]*vM())  // <— optional gleiches Verhalten fürs Video
    .scrollY(() =>              time*P.vid_mov.dir[1]*vM())
    .scale(() => P.vid_scl.abs + 1 + vS())
    .modulate(noiseV(), () => P.vid_warp * 0.05)
    .hue(() => P.vid_col.ho + P.vid_col.h * vC())
    .saturate(() => P.vid_col.so + P.vid_col.s * vC())
    .brightness(() => P.vid_col.vo + P.vid_col.v * vC());

  // Erstes Frame „schwarz“ in o0, damit Feedback sauber startet
  solid(0,0,0,1).out(o0);

  const comp =
    imgNode()
      .add(camNode(), () => P.blend)   // (du nutzt derzeit Add statt Blend)
      .add(sirenTex(), () => P.siren)
      .blend(src(o0), () => P.trail);

  comp.out(o0);
  render(o0);

  // ===== MIDI: ALLE Parameter per CC steuerbar (ohne rebuild) =====
  function setByPath(obj, path, val){
    const parts = path.split('.');
    const last = parts.pop();
    let ref = obj;
    for(const p of parts){ ref = /^\d+$/.test(p) ? ref[+p] : ref[p]; }
    ref[last] = val;
  }

  // --- helpers for MIDI mapping ---
  function mapLinear(d2, [outMin, outMax]) { const t = d2 / 127; return outMin + t * (outMax - outMin); }
  function mapBipolar(d2, [negMin, posMax], dead = 2) {
    const center = 63.5; if (Math.abs(d2 - center) <= dead) return 0;
    if (d2 > center) { const lo = center + dead; const t = (d2 - lo) / (127 - lo); return t * posMax; }
    const hi = center - dead; const t = (d2 - hi) / (0 - hi); return t * negMin;
  }
  function mapInt(d2, [minI, maxI]) { const t = d2 / 127; return Math.round(minI + t * (maxI - minI)); }

  // CC → Parameterpfad + Typ/Range (deine Belegung beibehalten)
  const CC_MAP = {
    // Mix/Global
    1: { path:'blend', type:'lin', range:[0,1] },
    2: { path:'trail', type:'lin', range:[0.0,0.99] },

    // Keying //
    5: { path:'key_on', type:'toggle', A:0, B:1 }, //
    6: { path:'key_thr', type:'lin', range:[0.0,0.3] },
    7: { path:'key_soft',type:'lin', range:[0.0,0.2] },
    8: { path:'key_mode',type:'toggle', A:'add', B:'alpha' },

    //Sirene
    10: { path:'siren', type:'lin', range:[0,1],},
    11: { path:'sir_spd', type:'bip', range:[4,-4], dead:2 },
    12: { path:'sir_w', type:'lin', range:[0.05,0.9] },
    13: { path:'sir_dir', type:'toggle', A:'x', B:'y' },
    14: { path:'sirA.0', type:'lin', range:[0,1] },
    15: { path:'sirA.1', type:'lin', range:[0,1] },
    16: { path:'sirA.2', type:'lin', range:[0,1] },
    17: { path:'sirB.0', type:'lin', range:[0,1] },
    18: { path:'sirB.1', type:'lin', range:[0,1] },
    19: { path:'sirB.2', type:'lin', range:[0,1] },

    // BILDQUELLE
    20: { path:'img_scl.src', type:'int', range:[0,7] },
    21: { path:'img_scl.fac', type:'bip', range:[-1,1], dead:2 },
    22: { path:'img_scl.att', type:'lin', range:[0.005,0.2] },
    23: { path:'img_scl.rel', type:'lin', range:[0.05,1.0] },
    24: { path:'img_scl.abs', type:'bip', range:[-1,1], dead:2 },
    30: { path:'img_mov.src', type:'int', range:[0,7] },
    31: { path:'img_mov.fac', type:'lin', range:[0,0.02] },
    32: { path:'img_mov.att', type:'lin', range:[0.005,0.2] },
    33: { path:'img_mov.rel', type:'lin', range:[0.05,1.0] },
    34: { path:'img_mov.dir.0', type:'bip', range:[-1,1], dead:2 },
    35: { path:'img_mov.dir.1', type:'bip', range:[-1,1], dead:2 },
    36: { path:'img_speed', type:'bip', range:[-0.2,0.2], dead:2 },
    40: { path:'img_col.src', type:'int', range:[0,7] },
    41: { path:'img_col.fac', type:'lin', range:[0,2.0] },
    42: { path:'img_col.att', type:'lin', range:[0.005,0.2] },
    43: { path:'img_col.rel', type:'lin', range:[0.05,1.0] },
    44: { path:'img_col.h', type:'bip', range:[-0.5,0.5], dead:2 },
    45: { path:'img_col.s', type:'lin', range:[0,2.0] },
    46: { path:'img_col.v', type:'lin', range:[0,1.0] },
    47: { path:'img_col.ho', type:'bip', range:[-1.0,1.0], dead:2 },
    48: { path:'img_col.so', type:'bip', range:[-1.0,1.0], dead:2 },
    49: { path:'img_col.vo', type:'bip', range:[-1.0,1.0], dead:2 },
    50: { path:'img_warp', type:'lin', range:[0,1.0] },
    51: { path:'img_wspd', type:'lin', range:[0.01,1.0] },

    // VIDEOQUELLE
    60: { path:'vid_scl.src', type:'int', range:[0,7] },
    61: { path:'vid_scl.fac', type:'bip', range:[-1,1], dead:2 },
    62: { path:'vid_scl.att', type:'lin', range:[0.005,0.2] },
    63: { path:'vid_scl.rel', type:'lin', range:[0.05,1.0] },
    64: { path:'vid_scl.abs', type:'bip', range:[-1,1], dead:2 },
    70: { path:'vid_mov.src', type:'int', range:[0,7] },
    71: { path:'vid_mov.fac', type:'lin', range:[0,0.02] },
    72: { path:'vid_mov.att', type:'lin', range:[0.005,0.2] },
    73: { path:'vid_mov.rel', type:'lin', range:[0.05,1.0] },
    74: { path:'vid_mov.dir.0', type:'bip', range:[-1,1], dead:2 },
    75: { path:'vid_mov.dir.1', type:'bip', range:[-1,1], dead:2 },
    76: { path:'vid_speed', type:'bip', range:[-0.2,0.2], dead:2 },
    80: { path:'vid_col.src', type:'int', range:[0,7] },
    81: { path:'vid_col.fac', type:'lin', range:[0,2.0] },
    82: { path:'vid_col.att', type:'lin', range:[0.005,0.2] },
    83: { path:'vid_col.rel', type:'lin', range:[0.05,1.0] },
    84: { path:'vid_col.h', type:'bip', range:[-0.5,0.5], dead:2 },
    85: { path:'vid_col.s', type:'lin', range:[0,1.0] },
    86: { path:'vid_col.v', type:'lin', range:[0,1.0] },
    87: { path:'vid_col.ho', type:'bip', range:[-1.0,1.0], dead:2 },
    88: { path:'vid_col.so', type:'bip', range:[-1.0,1.0], dead:2 },
    89: { path:'vid_col.vo', type:'bip', range:[-1.0,1.0], dead:2 },
    90: { path:'vid_warp', type:'lin', range:[0,1.0] },
    91: { path:'vid_wspd', type:'lin', range:[0.01,1.0] },
  };

  async function initMIDI_AllParams(){
    if (!('requestMIDIAccess' in navigator)) {
      console.warn('WebMIDI nicht verfügbar'); return;
    }
    const midi = await navigator.requestMIDIAccess();
    console.log(`MIDI Inputs: ${midi.inputs.size}`);
    midi.inputs.forEach(input=>{
      input.onmidimessage = (msg)=>{
        const [st, d1, d2] = msg.data;
        if ((st & 0xF0) !== 0xB0) return; // nur CC
        const map = CC_MAP[d1];
        if (!map) return;

        // Wert mappen
        let newVal;
        if (map.type === 'toggle') newVal = (d2 < 64) ? map.A : map.B;
        else if (map.type === 'int') { const t=d2/127; newVal = Math.round(map.range[0] + t*(map.range[1]-map.range[0])); }
        else if (map.type === 'bip') {
          const center=63.5, dead=map.dead ?? 2;
          if (Math.abs(d2-center) <= dead) newVal = 0;
          else if (d2>center){ const lo=center+dead; const t=(d2-lo)/(127-lo); newVal=t*map.range[1]; }
          else { const hi=center-dead; const t=(d2-hi)/(0-hi); newVal=t*map.range[0]; }
        } else { const t=d2/127; newVal = map.range[0] + t*(map.range[1]-map.range[0]); }

        // Setzen
        setByPath(P, map.path, newVal);

        // --- NEU: Speed-Startanker pflegen ---
        if (map.path === 'img_speed') {
          // 0 → ≠0: Startzeit auf "jetzt" setzen, damit Scroll bei 0 beginnt
          if (prevImgSpeed === 0 && newVal !== 0) imgSpeedStart = time;
          // optional: bei Rückkehr auf 0 neu „armen“
          if (newVal === 0) imgSpeedStart = time;
          prevImgSpeed = newVal;
        }
        if (map.path === 'vid_speed') {
          if (prevVidSpeed === 0 && newVal !== 0) vidSpeedStart = time;
          if (newVal === 0) vidSpeedStart = time;
          prevVidSpeed = newVal;
        }
      };
    });

    console.table(
      Object.entries(CC_MAP).map(([cc,cfg])=>({CC:+cc, Param:cfg.path, Type:cfg.type, Range:cfg.range||''}))
    );
  }
  await initMIDI_AllParams();

  // Deprecation-Warnung von hydra-synth/Meyda ist unkritisch.

</script>
</body>
</html>
